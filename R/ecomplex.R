
#' Compute the epsilon-complexity of a time series.
#'
#' @param x A vector of points. 
#' @param ds Number of times to downsample the input sequence.
#' @param method The interpolation or approximation method. One of
#'                c("bspline", "cspline")
#' @param max_degree The maximum order spline used in the approximation
#'              step
#'
#' @return A \code{list} with :
#' \tabular{ll}{
#' \code{A}        \tab The epsilon-complexity intercept coefficient \cr
#' \code{B}        \tab The epsilon-complexity slope coefficient \cr
#' \code{fit}      \tab The full linear model generated by fitting log(epsilons) ~ log(S) using \code{lm()}. \cr
#' \code{epsilons} \tab The mean sum of absolute errors at each downsample level. \cr
#' \code{S}        \tab The fraction of samples maintained at each downsample level. \cr
#' \code{method}  \tab The method used or a list of methods if method 
#'                      "all" is used. 
#'}
#'@export
ecomplex <- function(x, method = c("cspline", "bspline", "lift", "all"), 
                        ds = 6, 
                        max_degree = 5) {

  if (!is.null(dim(x))) stop("Data must be a vector of numeric values")
  x <- as.numeric(x)
  if (anyNA(x))         stop("Data contains NA values")
  if (length(x) < 100)  warning("Complexity estimate may not be stable ", 
                                "for short series")  
  x      <- normalize(x)
  method <- match.arg(method)
 
  func <- structure(list(x     = x, 
                         ds    = ds, 
                         deg   = max_degree),
                         class = method)

  res <- get_epsilons(func)  
  S   <- 1 / (2:(length(res$epsilons) + 1))
  fit <- NA  
  try({      
     fit <- lm(log(res$epsilons) ~ log(S))   
  }, silent = FALSE )

  structure(list(A        = unname(coefficients(fit)[1]),
                 B        = unname(coefficients(fit)[2]),
                 fit      = fit, 
                 epsilons = res$epsilons, 
                 S        = S,
                 method   = res$methods), 
                 class    = "ecomplex")
}

#' Compute epsilon errors for a time series.
#'
#' Computes the mean absolute error (MAE) of a time
#'  series for each downsample level using an 
#'  interpolation (or approximation) method of type
#'  basis-spline, cubic spline or lifting sche 
#'
#' @param func A structure with the time series, interpolation method, 
#'              and parameters for the method.
#' @return A \code{list} with :
#' \tabular{ll}{
#' \code{epsilons} \tab The mean sum of absolute errors at each level \cr
#' \code{methods}  \tab The method used or a list of methods if method 
#'                      "all" is used. 
#'}
get_epsilons <- function(func) UseMethod("get_epsilons")

get_epsilons.bspline <- function(func){
  epsilons <- double(func$ds - 1)
  ds <- 2:func$ds
    for (k in ds) {
    epsilons[k - 1] <- bspline_err(func$x, sample_num = k, max_degree = func$deg)
  }
  list(epsilons = epsilons, methods = class(func))
}

get_epsilons.cspline <- function(func){
  epsilons <- double(func$ds - 1)
  ds <- 2:func$ds
    for (k in ds) {
    epsilons[k - 1] <- cspline_err(func$x, sample_num = k, max_degree = func$deg)
  }
  list(epsilons = epsilons, methods = class(func))
}

get_epsilons.lift <- function(func) {
  ds <- min(func$ds, 6)
  epsilons <- unlist(lapply((2:ds), function(y) interp_err(func$x, iwt_mod(y))))
  list(epsilons = epsilons, methods = class(func))
}

get_epsilons.all <- function(func){
  methods <- c("cspline", "bspline", "lift")
  if (length(func$x) > 800 ) {
    methods <- c("cspline", "lift")
  }
  eps <- lapply(methods, 
                function(method) get_epsilons({class(func) <- method; func}))
  eps <- lapply(eps, function(eps) eps$epsilons)
  df <- data.frame(do.call(cbind, eps))
  names(df) <- methods
  # get minimum epsilons
  epsilons <- apply(df, 1, min)
  methods_used  <- methods[apply(df, 1, which.min)]
  list(epsilons = epsilons, methods = methods_used)
}

#' Function returns result for a single downsample level.
#' 
#' @param y           A vector or time series. 
#' @param sample_num   The amount the series is downsampled.
#' @param max_degree   The maximum degree spline polynomial to fit.
#' @importFrom splines bs
bspline_err <- function(y, sample_num, max_degree) {
  x <- 1:length(y)
  df <- data.frame(x = x, y = y); 
  indices  <- downsample_perm(length(y), sample_num);#
  # minimum error for each permutation
  epsilons <- double(length(indices))
  for (k in 1:sample_num) {
    cur_knots <- indices[[k]]
    ind       <- 1:length(x)
    hold_out  <- ind[-cur_knots];
    # errs holds the absolue errors for each index set
    errs <- matrix(0, nrow = max_degree, ncol = length(hold_out))
    for (deg in 1:max_degree) {
        basis  <- splines::bs(x, knots = cur_knots, degree = deg)
        yhat <- NA  
        try({      
           fit      <- lm(y ~ basis, data = df);
           # Average on full prediction 
           yhat     <- stats::predict(fit)[hold_out]
           errs[deg,] <- abs(y[hold_out] - yhat) / length(y)
        }, silent = T )
    }
    if (any(is.na(errs[deg, ]))) { 
      epsilons[k] <- NA 
    } else { 
      epsilons[k] <- min(apply(errs, 1, sum)) 
    }
  }
  return(mean(epsilons))
}


# return mean errors for given sample_num
cspline_err <- function(y, sample_num, max_degree = NULL) {
  x <- 1:length(y)
  indices  <- downsample_perm(length(y), sample_num);

  epsilons <- double(length(indices))
  for (k in 1:sample_num) {
    ind  <- indices[[k]]
    xout <- x[-ind];
    yout <- spline(ind, y[ind], xout = xout)
    # Average assuming sample points fit is exact
    epsilons[k]  <- sum(abs(yout$y - y[-ind])) / length(y) 
  }
  return(mean(epsilons))
}