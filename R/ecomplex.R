
#' Compute the epsilon-complexity of a time series.
#'
#' @param x A vector of points. 
#' @param ds Number of times to downsample the input sequence.
#' @param method The interpolation or approximation method. One of
#'                c("bspline", "cspline")
#' @param max_degree The maximum order spline used in the approximation
#'              step
#'
#' @return A list of features or the slope coefficient of the fit.
#'
#'@export
ecomplex <- function(x, method = c("bspline", "cspline", "lift"), 
                        ds = 6, 
                        max_degree = 5){

  if(!is.null(dim(x))) stop("data must be a vector of numeric values")
  x <- as.numeric(x)
  if(anyNA(x))         stop("data contains NA values")
  if(length(x) < 100)  warning("complexity estimate may not be stable + 
                                for short series")
  if(!is.numeric(x))   warning("data must be a numeric vector")
  
  x        <- normalize(x)
  method   <- match.arg(method)
 
  cat("method", method, "\n")
  func <- structure(list(x     = x, 
                         ds    = ds, 
                         deg   = max_degree),
                         class = method)

  epsilons <- get_epsilons(func)  
  S <- 1/(2:(length(epsilons)+1))
  cat("len", length(epsilons), "\n")
  fit <- NA  
  try({      
     fit <- lm(log(epsilons) ~ log(S))   
  }, silent = FALSE )
  
  structure(list(fit     = fit, 
                 epsilons = epsilons, 
                 S        = S,
                 method   = method), 
                 class    = "ecomplex")
}

#' Generate a function from a model
#'
#' @param mod A function model
#' @return Returns a function based on the model 
#'  parameters in mod 
#' @export
get_epsilons <- function(mod) UseMethod("get_epsilons")

get_epsilons.bspline <- function(func){
  epsilons <- double(func$ds - 1)
  ds <- 2:func$ds
    for(k in ds){
    epsilons[k-1] <- bspline_err(func$x, sample_num = k, max_degree = func$deg)
  }
  epsilons
}

get_epsilons.cspline <- function(func){
  epsilons <- double(func$ds - 1)
  ds <- 2:func$ds
    for(k in ds){
    epsilons[k-1] <- cspline_err(func$x, k, func$max_degree)
  }
  epsilons
}

#'  Compute epsilon-complexity using the lifting scheme
#'
#'  Computes the epsilon-complexity coefficient of a 
#'   time series using a wavelet lifting scheme.
#'
#' @param  func The function class 
#'
#' @return A \code{list} with :
#'
#' \tabular{ll}{
#' \code{coefficients} \tab The epsilon-complexity coefficients,\cr
#' \code{fit} \tab The complete linear model generated by lm(), \cr
#' \code{epsilons} \tab The mean sum of absolute errors at each level \cr
#' \code{S}     \tab The fraction of points removed at each level 
#'}
get_epsilons.lift <- function(func){
  ds <- min(func$ds, 6)
  epsilons <- unlist(lapply((2:ds), function(y) interp_err(func$x, iwt_mod(y))))
}

#' Function returns result for a single downsample level.
#' 
#' @param y           A vector or time series. 
#' @param sample_num   The amount the series is downsampled.
#' @param max_degree   The maximum degree spline polynomial to fit.
#' @export
bspline_err <- function(y, sample_num, max_degree){
  x <- 1:length(y)
  df <- data.frame(x = x, y = y); 
  indices  <- downsample_perm(length(y), sample_num);#
  # minimum error for each permutation
  epsilons <- double(length(indices))
  for (k in 1:sample_num) {
    cur_knots = indices[[k]]
    ind       = 1:length(x)
    hold_out  = ind[-cur_knots];
    # errs holds the absolue errors for each index set
    errs <- matrix(length(hold_out)*max_degree, 
                         nrow = max_degree, 
                         ncol = length(hold_out))
    for (deg in 1:max_degree){
        basis  <- splines::bs(x, knots = cur_knots, degree = deg)
        yhat <- NA  
        try({      
           fit      <- lm(y ~ basis, data = df);
           yhat     <- stats::predict(fit)[hold_out]
           errs[deg,] <- abs(y[hold_out] - yhat)
        }, silent = T )
    }
    if(any(is.na(errs[deg,]))){ 
      epsilons[k] <- NA 
    } else {
      epsilons[k]  <- min(apply(errs, 1, sum))/length(y) 
    }
  }
  return(mean(epsilons))
}


# return mean errors for given sample_num
cspline_err <- function(y, sample_num, max_degree = NULL){
  x <- 1:length(y)
  indices  <- downsample_perm(length(y), sample_num);

  epsilons <- double(length(indices))
  for (k in 1:sample_num) {
    ind = indices[[k]]
    xout  = x[-ind];
    yout <- spline(ind, y[ind], xout = xout)
    epsilons[k]  <- sum(abs(yout$y - y[-ind])) 
  }
  return(mean(epsilons))
}

